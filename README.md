# 前端性能测试项目

这个项目包含两个专门的性能测试模块：Undo/Redo 历史记录管理测试和流式细胞仪数据转换性能测试。

## Undo/Redo 历史记录管理测试

### 背景
在现代前端应用中，撤销/重做功能是用户体验的重要组成部分。当处理大规模数据结构（如复杂的实验数据）时，如何高效地实现历史记录管理成为一个挑战。本测试通过对比多种不可变数据方案，帮助开发者选择最适合的实现方式。

### 测试方案

#### 实现方案对比
1. **Lodash deepclone**
   - 传统的深拷贝方案
   - 每次操作创建完整副本
   - 作为基准性能参考

2. **JSON.stringify**
   - 序列化方案
   - 实现简单，使用广泛
   - 适用于简单数据结构

3. **Klona**
   - 优化的深拷贝库
   - 针对性能优化
   - 适用于复杂对象

4. **Immer**
   - 基于 Proxy 的不可变更新
   - 写时复制（CoW）策略
   - 开发体验友好

5. **Immutable.js**
   - 持久化数据结构
   - 高效的结构共享
   - 专业的不可变库

6. **Native Immutable**
   - 原生 JavaScript 实现
   - Object.freeze 保证不可变性
   - 无额外依赖

#### 测试场景
- 添加操作：模拟数据添加
- 删除操作：模拟数据删除
- 深度修改：模拟数据更新

## 流式细胞仪数据转换性能测试

### 背景
在流式细胞仪软件的 Angular 前端中，BiexponentialTranslator 负责处理大量的数据转换操作，其性能直接影响图表的刷新速度和用户交互体验。通过性能测试，我们可以识别并优化关键性能瓶颈。

### 测试场景

1. **实例化性能**
   - 测试转换器初始化速度
   - 对比普通实例化与缓存策略
   - 评估不同参数对初始化的影响

2. **线性转换性能 (translateToLinear)**
   - 测试数据标准化转换
   - 模拟实时数据处理场景
   - 评估大批量数据处理性能

3. **反向转换性能 (translateFromLinear)**
   - 测试数据反向转换
   - 模拟图表比例尺转换
   - 评估坐标转换效率

4. **数值计算性能**
   - solve 方法：评估数学计算效率
   - inverse 方法：测试反函数性能
   - seriesBiexponential：评估级数计算性能

5. **内存占用测试**
   - 测试缓存策略的内存影响
   - 评估单个实例的内存占用
   - 测试不同参数组合的内存效率
   - 样本数：1000

### 性能指标
- 操作耗时（微秒级）
- 批处理效率
- 内存使用情况
  - 总体内存占用（KB）
  - 每实例平均内存（KB）
  - 缓存实例数量
- 平均响应时间

### 内存优化建议
1. **缓存策略优化**
   - 限制最大缓存实例数
   - 实现 LRU 缓存淘汰
   - 监控内存阈值

2. **参数优化**
   - 合理设置参数精度
   - 复用相近参数的实例
   - 定期清理未使用实例

## 使用方法

### 运行测试

## 注意事项

1. **数据规模**
   - 可通过 `generateLargeData` 调整测试数据量
   - 默认生成适度规模的测试数据
   - 可根据需要调整数据复杂度

2. **内存考量**
   - 大规模测试可能需要较大内存
   - 建议在开发环境进行测试
   - 注意监控内存使用情况

3. **测试环境**
   - 建议在 Chrome 开发者工具中进行测试
   - 可使用 Performance 面板分析详细性能数据
   - 考虑禁用垃圾回收对测试的影响

### Chrome 启动命令

为了获取准确的内存使用数据和启用手动垃圾回收，需要使用特定参数启动 Chrome：

#### Windows
```bash
"C:\Program Files\Google\Chrome\Application\chrome.exe" --enable-precise-memory-info --js-flags="--expose-gc" --enable-memory-info
```

#### macOS
```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --enable-precise-memory-info --js-flags="--expose-gc" --enable-memory-info
```

#### Linux
```bash
google-chrome --enable-precise-memory-info --js-flags="--expose-gc" --enable-memory-info
```

参数说明：
- `--enable-precise-memory-info`: 启用精确的内存信息统计
- `--js-flags="--expose-gc"`: 暴露垃圾回收接口，允许手动触发 GC
- `--enable-memory-info`: 启用额外的内存信息

### 开发者工具使用建议

1. **内存面板（Memory）**
   - 使用堆快照（Heap Snapshot）分析内存占用
   - 观察内存泄漏情况
   - 分析对象引用关系

2. **性能面板（Performance）**
   - 记录内存使用趋势
   - 分析垃圾回收行为
   - 观察内存分配情况

3. **任务管理器**
   - 监控整体 JavaScript 内存使用
   - 观察 DOM 节点数量
   - 跟踪事件监听器数量

## 内存使用对比

### 各方案内存特征

1. **Lodash Deep Clone**
   - 每次操作都创建完整的数据副本
   - 内存使用随数据规模线性增长
   - 垃圾回收压力大
   - 适用场景：数据规模小，操作频率低

2. **JSON Serialization**
   - 序列化过程需要额外的字符串内存
   - 反序列化时创建新对象
   - 内存峰值较高
   - 适用场景：需要序列化存储的场景

3. **Klona**
   - 优化的深拷贝实现
   - 比 Lodash 更低的内存占用
   - 更快的内存释放
   - 适用场景：需要高性能深拷贝的场景

4. **Immer**
   - 基于代理的写时复制
   - 仅复制修改路径
   - 较低的内存开销
   - 适用场景：频繁的小规模修改

5. **Immutable.js**
   - 持久化数据结构
   - 高效的结构共享
   - 稳定的内存使用模式
   - 适用场景：大规模数据的频繁修改

6. **Native Immutable**
   - 基于原生 JavaScript 的写时复制
   - 适中的内存使用
   - 简单直观的内存模型
   - 适用场景：中等规模数据的一般操作

### 内存使用模式

#### 添加操作
- Immutable.js 和 Immer 表现最好，因为它们能够共享未修改的结构
- JSON 和 Lodash 的内存使用最高，因为需要完整复制
- Native Immutable 和 Klona 处于中间水平

#### 删除操作
- 所有方案的内存使用相对添加操作都较低
- Immutable.js 的内存释放最高效
- 其他方案的表现相近

#### 深度修改
- Immutable.js 和 Immer 因为路径共享而表现最好
- JSON 和 Lodash 需要完整复制，内存使用最高
- Native Immutable 因为需要复制修改路径，内存使用适中

### 内存优化建议

1. **选择合适的实现**
   - 小数据量：可以使用简单的深拷贝
   - 大数据量：推荐使用 Immutable.js 或 Immer
   - 中等数据量：可以考虑 Native Immutable

2. **内存管理策略**
   - 及时清理不需要的历史记录
   - 限制历史记录数量
   - 考虑使用内存池
   - 注意垃圾回收时机

3. **监控和优化**
   - 监控内存使用趋势
   - 识别内存泄漏
   - 优化数据结构
   - 合理设置更新频率

### 测试结果示例

## 结论

不同实现方案各有优势：
- Immutable.js：适合大规模数据的频繁更新
- Native Immutable：适合中小规模数据的简单操作
- Immer：适合需要可变式 API 的场景
- 其他方案各有特定使用场景

选择合适的实现方案应考虑：
1. 数据规模和复杂度
2. 操作频率和类型
3. 内存限制
4. 开发便利性
5. 团队熟悉度

## 贡献

欢迎提交 Issue 和 Pull Request 来改进这个基准测试项目。
